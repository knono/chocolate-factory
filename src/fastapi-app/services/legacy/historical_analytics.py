"""
üè≠ Historical Analytics Service
An√°lisis de datos hist√≥ricos REE para optimizaci√≥n de f√°brica
"""

from datetime import datetime, timedelta
from typing import List, Optional
from pydantic import BaseModel
import logging
from influxdb_client import InfluxDBClient
from influxdb_client.client.query_api import QueryApi
import statistics

logger = logging.getLogger(__name__)

class FactoryMetrics(BaseModel):
    """M√©tricas de consumo de f√°brica"""
    total_kwh: float
    avg_daily_cost: float
    peak_consumption: float  # kW
    total_cost: float
    days_analyzed: int

class PriceAnalysis(BaseModel):
    """An√°lisis de precios hist√≥ricos"""
    min_price_eur_kwh: float
    max_price_eur_kwh: float
    avg_price_eur_kwh: float
    volatility_coefficient: float
    price_range_eur_kwh: float

class OptimizationPotential(BaseModel):
    """Potencial de optimizaci√≥n"""
    total_savings_eur: float
    optimal_production_hours: int
    annual_savings_projection: float
    efficiency_improvement_pct: float

class HistoricalAnalytics(BaseModel):
    """Analytics hist√≥ricos completos"""
    factory_metrics: FactoryMetrics
    price_analysis: PriceAnalysis
    optimization_potential: OptimizationPotential
    recommendations: List[str]
    analysis_period: str
    last_update: str

class HistoricalAnalyticsService:
    """Servicio de an√°lisis hist√≥rico de datos REE"""
    
    def __init__(self):
        # Configuraci√≥n InfluxDB usando las mismas variables de entorno que data_ingestion
        import os
        self.influx_client = InfluxDBClient(
            url=os.getenv("INFLUXDB_URL", "http://influxdb:8086"),
            token=os.getenv("INFLUXDB_TOKEN", ""),
            org=os.getenv("INFLUXDB_ORG", "chocolate-factory")
        )
        self.query_api = self.influx_client.query_api()
        self.bucket = os.getenv("INFLUXDB_BUCKET", "energy-data")
        
        # Constantes de f√°brica (del TFM)
        self.FACTORY_PEAK_KW = 156  # kW pico
        self.FACTORY_DAILY_KWH = 2496  # kWh/d√≠a
        self.FACTORY_AVG_KW = 104  # kW promedio (2496/24)

    async def get_historical_analytics(self, days_back: int = 220) -> HistoricalAnalytics:
        """Obtiene analytics hist√≥ricos completos"""
        try:
            # Consultar datos hist√≥ricos REE
            ree_data = await self._query_ree_historical_data(days_back)
            
            if not ree_data:
                logger.warning("No historical REE data found")
                return self._create_empty_analytics()
            
            # Calcular m√©tricas
            factory_metrics = self._calculate_factory_metrics(ree_data)
            price_analysis = self._analyze_prices(ree_data)
            optimization_potential = self._calculate_optimization_potential(ree_data, price_analysis)
            recommendations = self._generate_recommendations(price_analysis, optimization_potential)
            
            return HistoricalAnalytics(
                factory_metrics=factory_metrics,
                price_analysis=price_analysis,
                optimization_potential=optimization_potential,
                recommendations=recommendations,
                analysis_period=f"√öltimos {days_back} d√≠as",
                last_update=datetime.now().isoformat()
            )
            
        except Exception as e:
            logger.error(f"Historical analytics error: {e}")
            return self._create_empty_analytics()

    async def _query_ree_historical_data(self, days_back: int) -> List[dict]:
        """Consulta datos hist√≥ricos de REE desde InfluxDB"""
        try:
            query = f'''
                from(bucket: "{self.bucket}")
                |> range(start: -{days_back}d)
                |> filter(fn: (r) => r["_measurement"] == "energy_prices")
                |> filter(fn: (r) => r["_field"] == "price_eur_kwh")
                |> filter(fn: (r) => r["source"] == "REE")
                |> keep(columns: ["_time", "_value"])
                |> sort(columns: ["_time"])
            '''
            
            result = self.query_api.query(query)
            
            data = []
            for table in result:
                for record in table.records:
                    data.append({
                        'timestamp': record.get_time(),
                        'price_eur_kwh': record.get_value()
                    })
            
            logger.info(f"Retrieved {len(data)} historical REE records")
            return data
            
        except Exception as e:
            logger.error(f"Error querying historical REE data: {e}")
            return []

    def _calculate_factory_metrics(self, ree_data: List[dict]) -> FactoryMetrics:
        """Calcula m√©tricas de f√°brica basadas en datos hist√≥ricos"""
        if not ree_data:
            return FactoryMetrics(
                total_kwh=0, avg_daily_cost=0, peak_consumption=0, total_cost=0, days_analyzed=0
            )
        
        # Calcular d√≠as √∫nicos
        days_analyzed = len(set(record['timestamp'].date() for record in ree_data))
        
        # Calcular consumo total (basado en d√≠as analizados)
        total_kwh = days_analyzed * self.FACTORY_DAILY_KWH
        
        # Calcular costo total y promedio diario
        total_cost = sum(record['price_eur_kwh'] * self.FACTORY_DAILY_KWH/24 for record in ree_data)
        avg_daily_cost = total_cost / max(days_analyzed, 1)
        
        return FactoryMetrics(
            total_kwh=total_kwh,
            avg_daily_cost=avg_daily_cost,
            peak_consumption=self.FACTORY_PEAK_KW,
            total_cost=total_cost,
            days_analyzed=days_analyzed
        )

    def _analyze_prices(self, ree_data: List[dict]) -> PriceAnalysis:
        """Analiza precios hist√≥ricos"""
        if not ree_data:
            return PriceAnalysis(
                min_price_eur_kwh=0, max_price_eur_kwh=0, avg_price_eur_kwh=0,
                volatility_coefficient=0, price_range_eur_kwh=0
            )
        
        prices = [record['price_eur_kwh'] for record in ree_data]
        
        min_price = min(prices)
        max_price = max(prices)
        avg_price = statistics.mean(prices)
        price_range = max_price - min_price
        
        # Coeficiente de volatilidad (desviaci√≥n est√°ndar / promedio)
        volatility = statistics.stdev(prices) / avg_price if avg_price > 0 else 0
        
        return PriceAnalysis(
            min_price_eur_kwh=min_price,
            max_price_eur_kwh=max_price,
            avg_price_eur_kwh=avg_price,
            volatility_coefficient=volatility,
            price_range_eur_kwh=price_range
        )

    def _calculate_optimization_potential(self, ree_data: List[dict], price_analysis: PriceAnalysis) -> OptimizationPotential:
        """Calcula el potencial de optimizaci√≥n"""
        if not ree_data:
            return OptimizationPotential(
                total_savings_eur=0, optimal_production_hours=0, 
                annual_savings_projection=0, efficiency_improvement_pct=0
            )
        
        # Calcular ahorros potenciales operando solo en horas de precio bajo
        # Definir umbral de precio bajo (25% percentile)
        prices = [record['price_eur_kwh'] for record in ree_data]
        prices_sorted = sorted(prices)
        low_price_threshold = prices_sorted[len(prices_sorted)//4]  # 25% percentile
        
        # Horas √≥ptimas (precio bajo)
        optimal_hours = sum(1 for price in prices if price <= low_price_threshold)
        
        # Ahorros calculando diferencia entre precio promedio y precio bajo
        avg_hourly_consumption = self.FACTORY_DAILY_KWH / 24
        savings_per_optimal_hour = (price_analysis.avg_price_eur_kwh - low_price_threshold) * avg_hourly_consumption
        total_savings = optimal_hours * savings_per_optimal_hour
        
        # Proyecci√≥n anual
        days_in_sample = len(set(record['timestamp'].date() for record in ree_data))
        annual_savings = (total_savings / max(days_in_sample, 1)) * 365
        
        # Porcentaje de mejora de eficiencia
        efficiency_improvement = (total_savings / (price_analysis.avg_price_eur_kwh * len(ree_data) * avg_hourly_consumption)) * 100
        
        return OptimizationPotential(
            total_savings_eur=total_savings,
            optimal_production_hours=optimal_hours,
            annual_savings_projection=annual_savings,
            efficiency_improvement_pct=efficiency_improvement
        )

    def _generate_recommendations(self, price_analysis: PriceAnalysis, optimization: OptimizationPotential) -> List[str]:
        """Genera recomendaciones basadas en el an√°lisis"""
        recommendations = []
        
        if optimization.annual_savings_projection > 50000:
            recommendations.append("üéØ Implementar programaci√≥n inteligente: ahorros anuales superiores a 50.000‚Ç¨")
        
        if price_analysis.volatility_coefficient > 0.3:
            recommendations.append("‚ö° Alta volatilidad de precios: ideal para optimizaci√≥n temporal")
        
        if optimization.efficiency_improvement_pct > 20:
            recommendations.append(f"üìà Mejora de eficiencia del {optimization.efficiency_improvement_pct:.1f}% disponible")
        
        recommendations.append("üîÑ Considerar storage de energ√≠a para aprovechar precios m√≠nimos")
        recommendations.append("üìä Implementar alertas autom√°ticas para precios √≥ptimos")
        
        return recommendations

    def _create_empty_analytics(self) -> HistoricalAnalytics:
        """Crea analytics vac√≠os en caso de error"""
        return HistoricalAnalytics(
            factory_metrics=FactoryMetrics(
                total_kwh=0, avg_daily_cost=0, peak_consumption=156, total_cost=0, days_analyzed=0
            ),
            price_analysis=PriceAnalysis(
                min_price_eur_kwh=0, max_price_eur_kwh=0, avg_price_eur_kwh=0,
                volatility_coefficient=0, price_range_eur_kwh=0
            ),
            optimization_potential=OptimizationPotential(
                total_savings_eur=0, optimal_production_hours=0, 
                annual_savings_projection=0, efficiency_improvement_pct=0
            ),
            recommendations=["‚ùå Sin datos hist√≥ricos disponibles"],
            analysis_period="Sin datos",
            last_update=datetime.now().isoformat()
        )